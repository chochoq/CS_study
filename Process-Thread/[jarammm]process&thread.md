# 프로세스와 스레드

<br/>


💜**참고**

- `운영체제에서의 프로세스와 스레드`

    # 운영체제

    <br/>

    - **정의 : 시스템의 자원과 동작을 관리하는 소프트웨어**
        - 하드웨어를 관리하고
        - 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며
        - 시스템의 동작을 제어하는 시스템 소프트웨어

    - 운영체제의 기능
        - **프로세스 관리**

            > 운영체제에서 작동하는 `응용 프로그램을 관리`하는 기능이다.
            어떤 의미에서는 `프로세서(CPU : central processing unit) 관리`하는 것이라고 볼 수도 있다. **현재 CPU를 점유해야 할 프로세스를 결정**하고, 실제로 **CPU를 프로세스에 할당**하며, 이 프로세스 간 **공유 자원 접근과 통신 등을 관리**하게 된다.

            - **`프로세스, 스레드`**
            - 스케줄링
            - 동기화
            - IPC 통신
        - 저장장치 관리
        - 네트워킹
        - 사용자 관리
        - 디바이스 드라이버

<br/><br/>

> **프로세스** : 운영체제로부터 자원을 할당받은 `작업`의 단위 <br/>
**스레드** : 프로세스가 할당받은 자원을 이용하는 `실행 흐름`의 단위

<br/><br/>

## 프로그램 → 프로세스 → 스레드

1. **프로그램 → 프로세스**
    - **프로그램 :** 파일이 저장 장치에 저장되어 있지만 `**메모리에는 올라가 있지 않은` `정적인 상태`**
        - 1️⃣ **메모리에 올라가 있지 않은**

            아직 **운영체제가 프로그램에게 독립적인 메모리 공간을 할당해주지 않았다**는 뜻이다. 모든 프로그램은 운영체제가 실행되기 위한 **메모리 공간을 할당해 줘야 실행될 수 있다.**

        - 2️⃣ **정적인 상태**

            정적(靜的)이라는 단어 그대로, 움직이지 않는 상태라는 뜻이다. 한 마디로 **아직 실행되지 않고 가만히 있다**는 뜻

        > 1️⃣ 아직 실행되지 않은 파일 그 자체
        2️⃣ 윈도우의 *.exe 파일이나 MacOS의 *.dmg 파일 등등 사용자가 눌러서 실행하기 전의 파일
        3️⃣ 코드 덩어리

    - **프로세스 : `실행되고 있는 상태의 프로그램`**
        1. 프로그램 실행
        2. 해당 파일(프로그램)이 컴퓨터 메모리에 올라가게 됨

            **→ 이 상태를 `동적인 상태` , 이 상태의 프로그램을 `프로세스` 라고 함**

        3. 한 프로세스가 다른 프로세스의 자원에 접근하려면 **프로세스 간의 통신(IPC, inter-process communication)**을 사용해야 한다.
            1. ex. 파이프, 파일, 소켓 등을 이용한 통신 방법 이용

        ![Untitled](https://user-images.githubusercontent.com/90924434/134768834-01fa8437-a387-4014-97de-b49457d2da84.png)

<br/>

1. **프로세스 → 스레드**
    - **스레드의 등장**
        - **프로그램이 복잡**해질수록 프로세스 하나만으로 프로그램을 실행하기에는 벅차게 됨
        - **"한 프로그램을 처리하기 위한 프로세스를 여러 개 만들면 되지 않을까?"**

            **NO!**

            운영체제는 `안정성`을 위해, 1️⃣프로세스마다 자신에게 **할당된 메모리 내의 정보에만 접근**할 수 있도록 제약을 두고 있고, 2️⃣**이를 벗어나는 정보**에 접근하려면 **오류가 발생**하기 때문!

            **하나의 프로세스 안에서 복잡한 프로그램을 실행하기 위해서 스레드가 등장**

    - **스레드란 :** 스레드는 **프로세스의 코드에 정의된 절차**에 따라 실행되는 **특정한 수행 경로**
        - **프로세스의 특성의 한계를 해결**하기 위해 만들어진 개념
        - 프로세스와 다르게 **스레드 간 메모리를 공유**하며 작동
        - 스레드끼리 프로세스의 자원을 공유하면서 **프로세스 실행 흐름의 일부가 되는 것**
        - 프로그램이 `코드 덩어리`라면, 스레드는 코드 내 `선언된 함수`

    ![Untitled 1](https://user-images.githubusercontent.com/90924434/134768842-aa114185-fd04-4a83-a29e-4d122512a7fe.png)


- 프로세스들이 운영체제로부터 별도의 메모리 영역을 할당받은 모습

![Untitled 2](https://user-images.githubusercontent.com/90924434/134768848-29ad07e3-bad4-4832-a61c-bb2280af511c.png)

- 스레드들이 프로세스의 Code/Data/Heap 메모리 영역을 공유하는 모습

![Untitled 3](https://user-images.githubusercontent.com/90924434/134768856-39ac2d3d-be95-4d85-9c51-0299e40fefbf.png)

설명
****

**프로세스는 각각 별도의 주소공간 할당 (독립적)**

- **Code** : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
- **Data** : 전역변수, 정적변수, 배열 등
- **Heap** : 동적 할당 시 사용 (new(), malloc() 등)
- **Stack** : 지역변수, 매개변수, 리턴 값 (`**임시 메모리 영역**`)

**구역이 나누어진 이유**
: **메모리 공간은 한정적**이므로 **목적과 특성에 맞게 나누어 저장**해야 메모리 누수없이 효율적으로 관리가 가능하기 때문이다

**프로세스와 스레드의 차이**

- 한 프로세스에서 오류가 발생한다면❓

    공유하고 있는 파일을 손상시키는 경우가 아니라면, **다른 프로세스에는 아무런 영향을 주지 않는다**

- 한 스레드에서 오류가 발생한다면❓

    스레드는 **Code/Data/Heap 메모리 영역의 내용을 스레드 간 공유**하기 때문에 어떤 스레드 하나에서 오류가 발생한다면 **같은 프로세스 내의 다른 스레드 모두가 강제로 종료**된다.

- 스레드의 메모리 공유 방식
    - **CPU 관점에서** **스레드를 최소 작업 단위로** 삼고 작업을 처리
    - 반면 **OS 관점**에서는 **프로세스**가 최소 작업 단위
    - 따라서 운영체제는 프로세스보다 작게 작업할 수 없으므로, 프로세스보다 작은 단위인 스레드는 **하나의 프로세스 안에서 서로 메모리를 공유할 수밖에 없음(운영체제가 메모리를 할당하므로)**

<br/><br/>

## 멀티 프로세스



> **하나의 컴퓨터에 여러 CPU 장착 → 하나 이상의 프로세스들을 동시에 처리(병렬)**

![Untitled 4](https://user-images.githubusercontent.com/90924434/134768871-58d733c4-2ebe-44a1-92ce-64e248a8ccb1.png)

**장점**

- 안전성 (메모리 침범 문제를 OS 차원에서 해결)

**단점**

- 각각 독립된 메모리 영역을 갖고 있어, 작업량이 많을수록 오버헤드 발생. Context Switching으로 인한 성능 저하

- ***오버헤드***

    **오버헤드**(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.

    예를 들어 A라는 처리를 **단순하게 실행한다면 10초** 걸리는데, 안전성을 고려하고 부가적인 **B라는 처리를 추가**한 결과 처리시간이 **15초** 걸렸다면, **오버헤드는 5초**가 된다. 또한 이 처리 **B를 개선해 B'라는 처리**를 한 결과, 처리시간이 **12초**가 되었다면, 이 경우 **오버헤드가 3초 단축**되었다고 말한다

- ***Context Switching*이란?**

    **CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정(= 멀티태스킹)**

    즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말함

    → **프로세스는 각 독립된 메모리 영역을 할당**받아 사용되므로, 캐시 메모리 초기화와 같은 **무거운 작업이 진행되었을 때 오버헤드가 발생할 문제**가 존재함

- 부가 설명
    - 프로세서 vs. 프로세스

        작업의 과정이 파일로 저장되어 있으면 그것을 "프로그램"이라고 부르고 메모리에 적재되어 실행 중 이거나 실행 대기 중일 땐 "프로세스"라고 구별하여 부를 뿐입니다. 즉 프로세스는 "메모리에 적재되어 프로세서에 의해 실행중인 프로그램" 이라고정의하는 것이 정확할 것입니다.

    - context : CPU가 프로세스를 실행하기 위한 (프로세스에 대한) 정보(프로세스의 상태, 프로세스가 다음에 실행할 명령어, 레지스터 값, 프로세스 번호 등의 정보를 담고 있으며 이는 운영체제의 PCB(Process Control Block)에 저장됨)
    - CPU는 한번에 하나의 프로세스만 처리할 수 있음
    - 멀티프로세스 환경에서는 프로세스 간 CPU 자원 할당 이동이 일어날 수 밖에 없다 → 이러한 이동 과정을 `Context Switching`이라고 함
    - Context Switching 중에는 CPU의 자원이 어떤 프로세스에게 할당된 상태가 아니기 때문에 CPU가 **아무 일도 하지 못 한다.***  따라서 Context Switching 과정이 너무 자주 발생하면 오히려 CPU 성능이 떨어지게 된다.
        - **Context Switching 중의 CPU**

            정확히는 프로세스가 점유 중이지만 **사용 중은 아닌 상태**다. 특정 프로세스에 의해 **CPU 자원이 점유되고는 있는데, Context Switching 중이기 때문에 실제로 사용되는 프로세스가 없는 상태**인 것이다. CPU가 아무 일도 하지 못한다는 것은 결국 CPU 자원을 아무 프로세스도 사용하지 못한다는 말이고 이는 **오버헤드가 발생**되었다는 뜻이다

<br/><br/>

## 멀티 스레드



> 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것

- 스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌
- 윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 하고 있다.
- 웹 서버는 대표적인 멀티 스레드 응용 프로그램이다.

**장점**

- 독립적인 프로세스에 비해 Context-Switching할 때 **공유하고 있는 메모리만큼의 메모리 자원을 아낄 수 있음**
- **전역 변수와 정적 변수에 대한 자료 공유 가능**

**단점** : 안전성 문제. 하나의 스레드가 데이터 공간을 망가뜨리면, 모든 스레드가 작동 불능 상태 (공유 메모리를 갖기 때문)

- 멀티스레드의 안전성에 대한 단점은 `Critical Section` 기법을 통해 대비함
    - Critical Section 기법 : 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제를 해결하기 위한 **동기화 과정** → `상호 배제, 진행, 한정된 대기를 충족해야함` ( + 추가 공부 필요)

<br/><br/>

## 멀티 스레드를 지향하는 이유



1. 자원의 효율성
    - (멀티 프로세싱 시)프로세스 간 context-switching 시 오버헤드가 큼
2. 처리비용 감소 및 응답시간 단축
    - 별도의 IPC 통신(프로세스 간 통신-통신 비용 큼)에 대한 비용부담 감소
    - 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에, 스레드간 context-switching은 스택 영역만 처리되므로 응답시간 단축

<br/><br/>

---

- 참고

    [프로세스와 스레드의 차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)

    [프로세스 & 스레드 | 👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/operating-system/Process%20vs%20Thread.html)

    [오버헤드 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B2%84%ED%97%A4%EB%93%9C)

    [[OS] 프로세스와 스레드의 차이 - Heee's Development Blog](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
